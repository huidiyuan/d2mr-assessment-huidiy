hello_world <- function(name, current_time = Sys.time()){
# Sys.setlocale("LC_TIME", "English")
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
return(paste("Hello", name, "it is", display_time, "on a", time_of_day))
}
hello_world("Huidi")
hello_world("Huidi")
time_transfer(19)
random_greeting <- function(){
greetings <- c("Hello", "Hi", "Hey", "Greetings", "Salutations")
return(sample(greetings, 1))
}
hello_world <- function(name, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
return(paste(greeting, name, ", good", time_of_day, "it is", display_time))
}
hello_world("Huidi")
# Assign time of day based on current hour
time_transfer <- function(current_hour){
if (current_hour >= 6 && current_hour < 12) {
"morning"
} else if (current_hour >= 12 && current_hour < 18) {
"afternoon"
} else {
"evening"
}
}
hello_world <- function(name, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
return(paste(greeting, name, ", good", time_of_day, "!", "it is", display_time))
}
hello_world("Huidi")
hello_world("Huidi")
hello_world("Huidi")
?return()
?paste()
hello_world <- function(name, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time))
}
hello_world("Huidi")
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, "."))
hello_world <- function(name, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, "."))
}
hello_world <- function(name, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, "."))
}
hello_world <- function(name, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, "."))
}
# Assign time of day based on current hour
time_transfer <- function(current_hour){
if (current_hour >= 6 && current_hour < 12) {
"morning"
} else if (current_hour >= 12 && current_hour < 18) {
"afternoon"
} else {
"evening"
}
}
random_greeting <- function(){
greetings <- c("Hello", "Hi", "Hey", "Greetings", "Salutations")
return(sample(greetings, 1))
}
hello_world("Huidi")
hello_world("Huidi")
hello_world("Huidi")
# Load stringr package
library(stringr)
# Load stringr package
library(stringr)
hello_world <- function(raw_name, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Format raw_name to have the first letter capitalized and the rest lowercase
name <- str_to_title(raw_name)
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, "."))
}
# Assign time of day based on current hour
time_transfer <- function(current_hour){
if (current_hour >= 6 && current_hour < 12) {
"morning"
} else if (current_hour >= 12 && current_hour < 18) {
"afternoon"
} else {
"evening"
}
}
random_greeting <- function(){
greetings <- c("Hello", "Hi", "Hey", "Greetings", "Salutations")
return(sample(greetings, 1))
}
hello_world("Huidi")
hello_world("hUiDi")
# Load stringr package
library(stringr)
hello_world <- function(raw_name, class_day, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Format raw_name to have the first letter capitalized and the rest lowercase
name <- str_to_title(raw_name)
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, "."))
}
# Assign time of day based on current hour
time_transfer <- function(current_hour){
if (current_hour >= 6 && current_hour < 12) {
"morning"
} else if (current_hour >= 12 && current_hour < 18) {
"afternoon"
} else {
"evening"
}
}
random_greeting <- function(){
greetings <- c("Hello", "Hi", "Hey", "Greetings", "Salutations")
return(sample(greetings, 1))
}
# Set your class day
class_day <- c("Monday", "Tuseday", "Thursday")
hello_world("hUiDi", class_day)
Sys.Date()
weekdays(Sys.Date())
hello_world <- function(raw_name, class_day, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
weekday <- weekdays(Sys.Date())
# Format raw_name to have the first letter capitalized and the rest lowercase
name <- str_to_title(raw_name)
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, "."))
}
days_to_class <- function(weekday, class_day, course){
if (weekday %in% class_day){
days_remain <- 0
} else {
days_remain <- 1
while (course == FALSE){
if ((weekday + days_remain) %in% class_day){
course <- TRUE
} else {
days_remain <- days_remain + 1
}
}
}
}
days_to_class <- function(weekday, class_day){
if (weekday %in% class_day){
days_remain <- 0
} else {
course <- FALSE
days_remain <- 1
while (course == FALSE){
if ((weekday + days_remain) %in% class_day){
course <- TRUE
} else {
days_remain <- days_remain + 1
}
}
}
return(days_remain)
}
days_to_class("Monday", class_day)
days_to_class("Wednesday", class_day)
days_to_class(weekdays(Sys.Date()), class_day)
days_to_class <- function(class_day){
if (weekdays(Sys.Date()) %in% class_day){
days_remain <- 0
} else {
course <- FALSE
days_remain <- 1
while (course == FALSE){
if (weekdays(Sys.Date() + days_remain) %in% class_day){
course <- TRUE
} else {
days_remain <- days_remain + 1
}
}
}
return(days_remain)
}
> days_to_class(weekdays(Sys.Date()), class_day)
days_to_class(class_day)
# Load stringr package
library(stringr)
hello_world <- function(raw_name, class_day, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Format raw_name to have the first letter capitalized and the rest lowercase
name <- str_to_title(raw_name)
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
# Calculate days to class
days_remain <- days_to_class(class_day)
if (days_remain == 0){
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, ". ", "You are having class today!"))
}
elif (days_remain == 1){
# Load stringr package
library(stringr)
hello_world <- function(raw_name, class_day, current_time = Sys.time()){
# Convert the string to a POSIXct object
date_time <- as.POSIXct(current_time, format="%Y-%m-%d %H:%M:%OS")
# Format the POSIXct object to only include date and time up to minutes
display_time <- format(date_time, "%Y-%m-%d %H:%M")
current_hour <- as.numeric(format(current_time, "%H"))
# Format raw_name to have the first letter capitalized and the rest lowercase
name <- str_to_title(raw_name)
# Assign random greeting
greeting <- random_greeting()
# Assign time of day based on current hour
time_of_day <- time_transfer(current_hour)
# Calculate days to class
days_remain <- days_to_class(class_day)
if (days_remain == 0){
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, ". ", "You are having class today!"))
}
else if (days_remain == 1){
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, ". ", "You have class tomorrow!"))
}
else{
return(paste0(greeting, " ", name, ", good ", time_of_day, "! ", "It is ", display_time, ". ", "You have ", days_remain, " days until class."))
}
}
# Assign time of day based on current hour
time_transfer <- function(current_hour){
if (current_hour >= 6 && current_hour < 12) {
"morning"
} else if (current_hour >= 12 && current_hour < 18) {
"afternoon"
} else {
"evening"
}
}
random_greeting <- function(){
greetings <- c("Hello", "Hi", "Hey", "Greetings", "Salutations")
return(sample(greetings, 1))
}
days_to_class <- function(class_day){
if (weekdays(Sys.Date()) %in% class_day){
days_remain <- 0
} else {
course <- FALSE
days_remain <- 1
while (course == FALSE){
if (weekdays(Sys.Date() + days_remain) %in% class_day){
course <- TRUE
} else {
days_remain <- days_remain + 1
}
}
}
return(days_remain)
}
# Set your class day
class_day <- c("Monday", "Tuseday", "Thursday")
hello_world("hUiDi", class_day)
git config pull.rebase false
?expand()
?expand()
data("CO2")
str_c("CO2", "data")
library(tidyverse)
data("CO2")
str_c("CO2", "data")
str_glue("CO2", "data")
?str_c
?str_glue
?str_c
?str_flatten
str_flatten(letters[1:3], ", ")
str_flatten(letters[1:3], ", ", " and ")
str_flatten(letters[1:3], ", ", " and ", last = " or ")
str_flatten(letters[1:3], ", ", last = " or ")
?str_glue
name <- "Fred"
age <- 50
anniversary <- as.Date("1991-10-12")
str_glue(
"My name is {name}, ",
"my age next year is {age + 1}, ",
"and my anniversary is {format(anniversary, '%A, %B %d, %Y')}."
)
str_glue("My name is {name}, not {{name}}.")
?fct_rev()
f <- factor(c("a", "b", "c"))
fct_rev(f)
fct_infreq(f)
f <- factor(c(1,3,5,7))
fct_infreq(f)
f <- factor(c(1,7,2,4,9))
fct_infreq(f)
fct_infreq(f, ordered = TRUE)
?fct_infreq()
f <- factor(c("a", "c", "b"))
fct_infreq(f)
f <- factor(c(1,4,7,2))
fct_inseq(f)
library(tidyverse)
tibble1 <- tibble(col1 = c(1, 2, 3, 4, 5),
col2 = c(6, 7, 8, 9, 10),
col3 = c(11, 12, 13, 14, 15))
tibble2 <- tibble(col1 = c(16, 17, 18, 19, 20),
col2 = c(21, 22, 23, 24, 25),
col3 = c(26, 27, 28, 29, 30))
# a third with an extra column
tibble3 <- tibble(col1 = c(16, 17, 18, 19, 20),
col2 = c(21, 22, 23, 24, 25),
col3 = c(26, 27, 28, 29, 30),
col4 = c(31, 32, 33, 34, 35))
# a fourth with different column names
tibble4 <- tibble(col_1 = c(16, 17, 18, 19, 20),
col_2 = c(21, 22, 23, 24, 25),
col_3 = c(26, 27, 28, 29, 30))
# a fifth with a different number of rows
tibble5 <- tibble(col1 = c(16, 17, 18, 19, 20, 21),
col2 = c(21, 22, 23, 24, 25, 26),
col3 = c(26, 27, 28, 29, 30, 31))
tibble1
tibble2
tibble3
tibble4
tibble5
rbind(tibble1, tibble2) # works fine
bind_rows(tibble1, tibble2) # works fine, identical to rbind
bind_rows(tibble1, tibble3) # works fine, adds the extra column with NAs for missing the tibble1 values
bind_rows(tibble1, tibble4) # runs without error but treats the columns as different, so it adds the tibble4 columns to the end of the tibble1 columns
tibble4
tibble1
tibble5
bind_rows(tibble1, tibble4) # runs without error but treats the columns as different, so it adds the tibble4 columns to the end of the tibble1 columns
cbind(tibble1, tibble2) # works fine -- adds the columns of tibble2 to the right of tibble1, though it's not great that the columns have the same names
cbind(tibble1, tibble3) # works fine -- same number of rows, it's works like above
bind_cols(tibble1, tibble2) # works fine, identical to cbind *except* it renames the columns to avoid conflicts, which is preferable
bind_cols(tibble1, tibble4) # column names were already different, so it doesn't need to rename
band_members
band_instruments
# Inner join: only rows with matching values in both data frames are returned
# result: 2 rows, one for John and one for Paul
inner_join(band_members, band_instruments)
# Full join: all rows from both data frames are returned, with NAs for missing values
# result: 4 rows, one for each band member; NAs for Mick's instrument and Keith's band
full_join(band_members, band_instruments)
# Left join: all rows from the first data frame are returned, with NAs for missing values in the second data frame
# result: 3 rows, one for each band member in band_members; no Keith
left_join(band_members, band_instruments)
# Right join: all rows from the second data frame are returned, with NAs for missing values in the first data frame
# result: 3 rows, one for each band member in band_instruments; no Mick
right_join(band_members, band_instruments)
# For left and right joins, order matters! The first data frame is the "left" and the second is the "right"
# Which means a left join is the same as a right join with the data frames reversed (though row order will differ)
left_join(band_members, band_instruments)
right_join(band_instruments, band_members)
# The "by" argument specifies the column(s) to join on
# These are all identical
left_join(band_members, band_instruments)
left_join(band_members, band_instruments,
by = join_by(name))
left_join(band_members, band_instruments,
by = "name")
right_join(band_instruments, band_members)
band_instruments %>%
right_join(band_members,
by = "name")
# If the columns have different names, you can specify the columns to join on in each data frame
rename.band_members <- band_members %>%
rename(member = name)
# the order of the names should match the order of the dfs
left_join(rename.band_members, band_instruments,
by = c("member" = "name"))
# pivot mmdata (originally wide) to long
mmdata.long <- mmdata %>%
pivot_longer(cols = c("Red", "Green", "Blue", "Orange", "Yellow", "Brown"),
names_to = "Color",
values_to = "Number")
# Read in the mmdata from above if it's not loaded!
mmdata <- read_csv("00_in-class-materials/data/mmdata-ND.csv")
# pivot mmdata (originally wide) to long
mmdata.long <- mmdata %>%
pivot_longer(cols = c("Red", "Green", "Blue", "Orange", "Yellow", "Brown"),
names_to = "Color",
values_to = "Number")
mmdata.long
mmdata
# pivot long mmdata to wide; back to where it started
mmdata.wide <- mmdata.long %>%
pivot_wider(names_from = "Color", values_from = "Number") %>%
# Relocate works like select by reordering columns, but doesn't drop anything
# Kind of like how rename works like select by renaming but not dropping
relocate(Weight,.after = last_col())
mmdata.wide
# They are the same
mmdata.wide == mmdata
# Or are they??
all.equal(mmdata.wide, mmdata)
attributes(mmdata.wide)
attributes(mmdata)
# ?Q?: Is this wide or long?
glasses <- tibble(
condition = c(1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2),
participant = c(1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6),
score = runif(12),
notes = c("glasses_none", "glasses_none", "none_none", "none_none",
"none_incomplete", "none_incomplete", "none_none", "none_none",
"glasses_none", "glasses_none", "glasses_late", "glasses_late")
)
glasses
# Separate "notes" column into two columns by recognizing "_" separator
glasses.sep <- glasses %>%
separate(notes, c("vision_correction", "other_notes"), sep = "_")
glasses.sep
# *_position() will split based on integer values for each new column and for the separator
glasses.sep.pos <- glasses %>%
separate_wider_position(notes, c(vision_correction = 4, 1, other_notes = 4), too_many = "drop") # not super helpful here
# *_delim() will split based on a given separator, like separate()
# but has slightly different syntax
glasses.sep.delim <- glasses %>%
separate_wider_delim(notes, delim = "_", names = c("vision_correction", "other_notes"))
glasses.sep.delim
# Unite the 2 columns back to 1 with a new separator (use ; not _)
glasses.unite <- glasses.sep %>%
unite("semicolon_notes", "vision_correction":"other_notes", sep = ";")
glasses.unite
# ?Q? What's actually missing in this missingdata tibble?
missingdata <- tibble(
condition = c(1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2),
participant = c(1, NA, NA, NA, 2, NA, NA, NA, 3, NA, NA),
trial = c(1, 2, 3, 4, 1, 2, 3, 4, 1, 3, 4),
score = c(0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1),
)
